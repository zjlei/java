# 位运算 #

- &	与运算

	同1为1,否则为0
		
	1. 取二进制中一部分
		
		111011010011 我要取从左到右的第2到第5位,只要把下面的数对011110000000 进行&运算就好了
	2. 判断奇偶
	
		一个整数a, a & 1 这个表达式可以用来判断a的奇偶性。二进制的末位为0表示偶数，最末位为1表示奇数
	3. 判断n是否是2的正整数冪
	
		(!(n&(n-1)) )&& n	
	4. 统计n中1的个数
	
		考虑2位二进制数 n=11，里边有2个1，先提取里边的偶数位10，奇数位01，把偶数位右移1位，然后与奇数位相加，因为每对奇偶位相加的和不会超过“两位”，所以结果中每两位保存着数n中1的个数；相应的如果n是四位整数 n=0111，先以“一位”为单位做奇偶位提取，然后偶数位移位（右移1位），相加；再以“两位”为单位做奇偶提取，偶数位移位（这时就需要移2位），相加，因为此时没对奇偶位的和不会超过“四位”，所以结果中保存着n中1的个数，依次类推可以得出更多位n的算法。整个思想类似分治法
	5. 	对于正整数的模运算（注意，负数不能这么算）
		
		那么 mod 2^k 呢？（对2的倍数取模）

		n&((1<<k)-1)

		用通俗的言语来描述就是,对2的倍数取模，只要将数与2的倍数-1做按位与运算即可。

		好！方便理解就举个例子吧。

		思考：如果结果是要求模2^k时，我们真的需要每次都取模吗？

 

		在此很容易让人想到快速幂取模法。

- |	或运算
	
	同0为0,否则为1

- ^	异或运算
	
	相同为0,相异为1 
	
	0^0=0，0^1=1 0异或任何数＝任何数

　　1^0=1，1^1=0 1异或任何数－任何数取反

　　任何数异或自己＝把自己置0

	交换律:a ^ b = b ^ a
	
	结合律:a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c

	d = a ^ b ^ c 可以推出 a = d ^ b ^ c

	a ^ b ^ a = b.

	1. 使某些特定的位翻转
	
	　　例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
	
	　　10100001^00000110 = 10100111
		
		
	2. 实现两个值的交换，而不必使用临时变量
	
	　　例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：
	
	　　a = a^b； 　　//a=10100111
	
	　　b = b^a； 　　//b=10100001
	
	　　a = a^b； 　　//a=00000110
	
	
	3. 在汇编语言中经常用于将变量置零：
	
	　　xor a，a
	
	
	
	4. 快速判断两个值是否相等
	
	　　举例1： 判断两个整数a，b是否相等，则可通过下列语句实现：
	
	　　return （（a ^ b） == 0）
	
	
	5. 使用异或来判断一个二进制数中的1的数量是奇数还是偶数
		^a操作就是将a中的每一位按位逐一进行异或，例如a=4'b1010，则b=1^0^1^0=0，由此可以判断a中为1的位数是奇数还是偶数，是一个便捷的操作。

常用操作:

- 去掉最后一位: x >> 1 例:101101 >> 10110

- 在最后加0:x << 1 例:0b101101<<1

- 在最后加1:(x << 1) + 1 例:(0b101101<<1) + 0b1

- 把最后一位变0:(x | 1)-1	例:(0b101101 | 1) -1

- 把最后一位变1:x | 1 例:0b101101 | 1

- 最后一位取反:x ^ 1 例: 0b101101 ^ 1

- 把右数第K位变成1:x | (1 << (k -1))	例:

- 把右数第K位变成0:x & ~(1 << (k -1))

- 右数第K位取反:x ^ (1 << (k -1))

- 取末三位: 		x & 7

- 取末K位:		x &((1<<k)-1)

- 取右数第K位:	x >> (k -1) & 1

- 把末K位变成1:	x | ((1 << k) -1)

- 末K位取反:		x ^ ((1 << k) -1)

- 把右边连续的1变成0:	x & (x +1)

- 把右边连续的0变成1:	x | (x -1)

- 把右边连续的0变成1:	x | (x +1)

- 取右边连续的1:		(x ^ (x + 1))>>1

- 去掉右起第一个1的左边: x & (-x)

- 求绝对值
	- 位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样:
      1111 1010(二进制) –取反->0000 0101(二进制) -加1-> 0000 0110(二进制)
	来得到6。因此先移位来取符号位，int i = a >> 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断
	——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：
	int my_abs(int a){  
		int i = a >> 31;  
		return i == 0 ? a : (~a + 1);  
	}  

	
	

	- 现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：
	int my_abs(int a)  
	{  
	    int i = a >> 31;  
	    return ((a ^ i) - i);  
	}  


	- 给出一个问题：给你一个整形数组，这个数组中除了一个数字只出现一次外，其他数字都只出现两次，求出那个只出现一次的数字？
	nt get_one_num(int num[] , int n) {
	int first = num[0] , i;
	 for(i = 1; i < n; i++)
	 first ^= num[i];
	 return first;
	 }


	- 现在这个数组中，有两个数只出现了一次，求出这两个数字，且时间、空间复杂度不变。

		如果根据第一个问题的解法，我们最后面也是得到了一个值，但这个值是那两个数字（只出现一次）的异或值。我们又不知道这个两个数字的任何一个，所以我们得不到这两个数字。
	
	
		如果我们把数组分割成2个数组，每个数组中只含有一个只出现一次的数字，再调用问题一的解法，我们就能得到结果。
	
		关键在于我们怎么来分割这个数组，且空间复杂度是O(1)？
	
		首先我们从头到尾依次异或数组中的每一个数字，得到的结果就是两个只出现一次数字的异或结果，因为这两个数字肯定不一样，所以得到的结果数字肯定不是0，也就是这个二进制数字钟至少有一位是1 ， 我们在这个结果数字中华找到第一个为 1的位的位置，记为第n为，我们就通过第n位是不是1，一把这个数组分割成一个数组。
	
	int find_one(int x)
	{
	int p = 1;
	while(true)
	{
	if((p^x) < x)  break;
	p <<= 1;
	}
	return p;
	}
	 
	void get_one_num(int num , int n)
	{
	    int first = num[0] , i;
	    for(i = 1; i < n; i++)
	        first ^= num[i];
	    int one = find_one(first);
	 
	    int x = 0 , y = 0;
	    for(i = 0; i < n; i++)
	    {
	        if((one^num[i]) < num[i])
	            x ^= num[i];
	        else y ^= num[i];
	    }
	 
	    cout<<(x<y?x:y)<<" "<<(x>y?x:y)<<endl;
	}

